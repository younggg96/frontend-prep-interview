## Tell me more about the migration from Vue 2 to Next.js. Why did you decide to migrate. 

When I joined, our storefront was a large Vue 2 SPA. The bundle was quite large, there wasn’t a clear code-splitting strategy, and SEO was weak because everything was client-rendered.

We decided to migrate to Next.js mainly for three reasons:

to get server-side rendering and improve SEO,

to improve performance with better built-in code splitting, and

to have a cleaner architecture for future features.

## what were the hardest technical challenges?
The hardest challenge was rewriting this logic so it could work properly under Next.js’s SSR-based architecture.

In the old Vue 2 SPA, everything ran purely on the client.
All business logic—including doctor-order validation and patient eligibility checks—relied on browser, like localStorage, global state, and Vue lifecycle hooks. Tokens could only be read on the client, and all validations happened after the page loaded in the browser.

After migrating to Next.js, with SSR, we may not even have access to window or localStorage. Server Components cannot access any browser APIs. Cookies, sessions, and tokens now need to be read on the server. State can no longer depend on a single client store—you have to consider how server-side state and client-side state stay in sync.

The data-fetching model also changes completely: instead of everything running after mount, data may be fetched on the server during render, then hydrated on the client. And React’s rendering model does not use lifecycle hooks like Vue; it works through render → commit, which forces you to redesign when and where logic executes.

Because of these architectural differences, we had to redesign:

how tokens are stored and read,

which validation logic runs on the server vs the client,

how cart and checkout states are initialized,

how API calls are shared between server and client,

and the entire data-loading and page-loading sequence.

Essentially, it wasn’t only a code migration—it was a logic migration and a mindset shift.
The same business rules had to be re-engineered to run under a completely different execution environment, timing model, and rendering model.

And on top of that, we rebuilt the product detail, cart, and checkout flows in React while ensuring the behavior stayed 1:1 consistent with the old system. That combination made this the biggest technical challenge of the entire migration.